%{
    #include "output.hpp"
    int yylex();
    void yyerror(const char *err_msg);
    extern int yylineno;
%}

%nonassoc NUM
%token ID
%token STRING
%token INT
%token BYTE
%nonassoc B
%token BOOL
%left OR
%left AND
%token TRUE
%token FALSE
%token RETURN
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%right ASSIGN
%left EQU
%left BLE
%nonassoc BINOP
%left PLUS_MINUS
%left MULT_DIVIDE
%right NOT
%left LBRACE
%left RBRACE
%left LPAREN
%left RPAREN
%right ELSE





%%


Program : Statements {}
Statements : Statement {}
            | Statements Statement {}
Statement   : LBRACE Statements RBRACE {}
            | Type ID SC {}
            | Type ID ASSIGN Exp SC {}
            | ID ASSIGN Exp SC {}
            | Call SC {}
            | RETURN SC {}
            | IF LPAREN Exp RPAREN Statement {}
            | IF LPAREN Exp RPAREN Statement ELSE Statement {}
            | WHILE LPAREN Exp RPAREN Statement {}
            | BREAK SC {}
            | CONTINUE SC {}
Call : ID LPAREN Exp RPAREN {}
Type : INT {$$ = new Type($1); }
      | BYTE {$$ new Type($1);}
      | BOOL {$$ = new Type($1);}
Exp : LPAREN Exp RPAREN {$$ = $1;}
     | Exp MULT_DIVIDE Exp {}
     | Exp PLUS_MINUS Exp {}
     | ID {$$ = new ID($1);}
     | Call {}
     | NUM {$$ = new NUM($1);}
     | NUM B {is_byte($1); $ = new NUMB($1);} 
     | STRING {$$ = new STRING($1);}
     | TRUE {$$ = new BOOL($1);}
     | FALSE {$$ = new BOOL($1);}
     | NOT Exp {is_bool($2); $$ = ($1->value == "true") ? new BOOL("false") : new BOOL("true");}
     | Exp AND Exp {is_bool($1); is_bool($3); $$ = ($1->value == "false" || $3->value == "false") ? new BOOL("false") : new BOOL("true");}
     | Exp OR Exp {is_bool($1); is_bool($3); $$ = ($1->value == "false" && $3->value == "false") ? new BOOL("false") : new BOOL("true");}
     | Exp BLE Exp {is_num($1); is_num($3); $$ = calc_relop($1, $2, $3) ? new BOOL("true") : new BOOL("false");}
     | Exp EQU Exp {is_num($1); is_num($3); $$ = calc_relop($1, $2, $3) ? new BOOL("true") : new BOOL("false");}
     | LPAREN Type RPAREN Exp {}


%%


int main () {
    return yyparse();
}

void yyerror(const char *err_msg){
	output::errorSyn(yylineno);
	exit(0);
}
